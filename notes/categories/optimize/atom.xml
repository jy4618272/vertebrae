<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: optimize | Vertebrae framework]]></title>
  <link href="http://pixelhandler.github.com/vertebrae http://pixelhandler.github.com/vertebrae/notes/categories/optimize/atom.xml" rel="self"/>
  <link href="http://pixelhandler.github.com/vertebrae http://pixelhandler.github.com/vertebrae/"/>
  <updated>2012-07-12T11:32:22-07:00</updated>
  <id>http://pixelhandler.github.com/vertebrae http://pixelhandler.github.com/vertebrae/</id>
  <author>
    <name><![CDATA[Bill Heaton]]></name>
    <email><![CDATA[pixelhandler@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Optimize and Build a Backbone.js JavaScript application with Require.JS using Packages]]></title>
    <link href="http://pixelhandler.github.com/vertebrae http://pixelhandler.github.com/vertebrae/notes/optimize-and-build-a-backbone-dot-js-javascript-application-with-require-dot-js-using-packages/2012/01/09/"/>
    <updated>2012-01-09T03:19:00-08:00</updated>
    <id>http://pixelhandler.github.com/vertebrae http://pixelhandler.github.com/vertebrae/notes/optimize-and-build-a-backbone-dot-js-javascript-application-with-require-dot-js-using-packages/2012/01/optimize-and-build-a-backbone-dot-js-javascript-application-with-require-dot-js-using-packages</id>
    <content type="html"><![CDATA[<p>When a JavaScript application is too complex or large to build in a single file, grouping the application’s components into packages allows for script dependencies to download in parallel, and facilitates only loading <strong>packaged</strong> and other modular code as the site experience requires the specific set of dependencies.</p>

<p>Require.JS, the (JavaScript) module loading library, has an <a href="http://requirejs.org/docs/optimization.html" title="Require.JS optimizer">optimizer</a> to build a JavaScript-based application and provides various options. A build profile is the recipe for your build, much like a build.xml file is used to build a project with ANT. The benefit of building with <strong>r.js</strong> not only results in speedy script loading with minified code, but also provides a way to package components of your application.</p>

<ul>
<li><a href="http://requirejs.org/docs/optimization.html#onejs" title="Optimizing one JavaScript file">Optimizing one JavaScript file</a></li>
<li><a href="http://requirejs.org/docs/optimization.html#wholeproject" title="Optimizing a whole project">Optimizing a whole project</a></li>
<li><a href="http://requirejs.org/docs/faq-optimization.html#priority" title="Optimizing a project in layers or packages">Optimizing a project in layers or packages</a></li>
</ul>


<p>In a complex application, organizing code into <em>packages</em> is an attractive build strategy. The build profile in this article is based on an test application currently under development (files list below). The application framework is built with open source libraries. The main objective in this build profile is to optimize an application developed with <a href="http://documentcloud.github.com/backbone/" title="Backbone.js">Backbone.js</a> using modular code, following the <a href="https://github.com/amdjs/amdjs-api/wiki/AMD" title="Asynchronous Module Definition (AMD) wiki page">Asynchronous Module Definition (AMD)</a> format. AMD and Require.JS provide the structure for writing modular code with dependencies. Backbone.js provides the code organization for developing models, views and collections and also interactions with a RESTful API.</p>

<!--more-->


<p>Below is an outline of the application’s file organization, followed by the build profile to build modular (or packaged) layers a JavaScript driven application.</p>

<h3>File organization</h3>

<p>Assume the following directories and file organization, with app.build.js as the build profile (a sibling to both source and release directories). Note that the files in the list below named <em>section</em> can be any component of the application, e.g. <em>header</em>, <em>login</em>)</p>

<p><code>``text  
.-- app.build.js
|-- app-release
</code>-- app-src</p>

<pre><code>|-- collections
|   |-- base.js
|   |-- sections-segments.js
|   `-- sections.js
|-- docs
|   `--docco.css
|-- models
|   |-- base.js
|   |-- branding.js
|   `-- section.js
|-- packages
|   |-- header
|   |   |-- models
|   |   |   |-- nav.js
|   |   |   `-- link.js
|   |   |-- templates
|   |   |   |-- branding.js
|   |   |   |-- nav.js
|   |   |   `-- links.js
|   |   `-- views
|   |       |-- nav.js
|   |       |-- branding.js
|   |       `-- link.js
|   |-- header.js
|   `-- ... more packages here e.g. cart, checkout ...
|-- syncs
|   |-- rest
|   |   `-- sections.js
|   |-- factory.js
|   `-- localstorage.js
|-- test
|   |-- fixtures
|   |   `-- sections.json
|   |-- header
|   |   |-- index.html
|   |   `-- spec.js
|   |-- lib
|   |   `-- Jasmine
|   |-- models
|   |-- utils
|   |-- global-spec.js
|-- utils
|   |-- ajax.js
|   |-- baselib.js
|   |-- debug.js
|   |-- localstorage.js
|   `-- shims.js
|-- vendor
|-- |-- backbone-min.js
|   |-- jquery-1.7.1.min.js
|   |-- jquery.mobile-1.0.min.js
|   |-- json2.js
|   |-- modernizr-1.6.min.js
|   |-- mustache.js
|   |-- require.js
|   |-- text.js
|   `-- underscore.js
|-- views
|   |-- base.js
|   `-- collection.js
|-- application.js
|-- collections.js
|-- index.html
|-- main.js
|-- models.js
|-- syncs.js
|-- utils.js
|-- vendor.js
`-- views.js
</code></pre>

<p>```</p>

<h3>Build profile to optimize modular dependencies with code organized in packages</h3>

<p>The build profile can be organized to <a href="http://requirejs.org/docs/faq-optimization.html#priority" title="optimize modular dependencies in packages">divide parallel downloads for various sections of the application</a>.</p>

<p>This strategy demonstrated builds common or site-wide groups of (core) <em>models</em>, <em>views</em>, collections which are extended from a base.js constructor which extends the appropriate backbone method, e.g. Backbone.Model. The <em>packages</em> directory organizes code by section / responsibility, e.g. cart, checkout, etc. Notice that within the example <em>header</em> package the directory structure is similar to the app root directory file structure. A <em>package</em> (of modularized code) has dependencies from the common libraries in your application and also has specific code for the packages execution alone; other packages should not require another packages dependencies. A <em>utils</em> directory has shims, helpers, and common library code to support the application. A <em>syncs</em> directory to define persistence with your RESTful api and/or localStorage. The <em>vendor</em> libraries folder will not be built, there is no need to do so, you may decide to use a CDN (then set these paths to : <em><a href="http://requirejs.org/docs/optimization.html#empty" title="empty:">empty:</a></em>). And finally a <em>test</em> directory for <a href="http://pivotal.github.com/jasmine/" title="Jasmine is a behavior-driven development framework for testing your JavaScript code">Jasmine</a> unit test specs, which may be ignored in the build as well if you choose.</p>

<p>Also notice the there are .js files named the same as the directories, these are the files listed in the paths. these are strategic to group sets of files to build, examples follow the build profile below.</p>

<p>```javascript
({</p>

<pre><code>appDir: './app-src',
baseUrl: './',
dir: './app-build',
optimize: 'uglify',
paths: {
    // will not build 3rd party code, it's already built
    'text'         : 'vendor/text',
    'json2'        : 'vendor/json2.min',
    'modernizr'    : 'vendor/modernizr-1.6.min',
    'jquery'       : 'vendor/jquery-1.7.1',
    'jquerymobile' : 'vendor/jquery.mobile-1.0.min.js',
    'underscore'   : 'vendor/underscore',
    'mustache'     : 'vendor/mustache',
    'backbone'     : 'vendor/backbone',
    // files that define dependencies...
    // ignore vendor libraries, but need a group to do so
    'vendor'       : 'vendor',
    // application modules/packages these files define dependencies
    // and may also group modules into objects if needed to require
    // by groups rather than individual files
    'utils'        : 'utils',
    'models'       : 'models',
    'views'        : 'views',
    'collections'  : 'collections',
    // packages to build
    'header'       : 'packages/header'
    //... more packages
},
modules: [
    // Common libraries, Utilities, Syncs, Models, Views, Collections
    {
        name: 'utils',
        exclude: ['vendor']
    },
    {
        name: 'syncs',
        exclude: ['vendor', 'utils']
    },
    {
        name: 'models',
        exclude: ['vendor', 'utils', 'syncs']
    },
    {
        name: 'views',
        exclude: ['vendor', 'utils', 'syncs', 'models']
    },
    {
        name: 'collections',
        exclude: ['vendor', 'utils', 'syncs', 'models', 'views']
    },
    // Packages
    {
        name: 'header',
        exclude: ['vendor', 'utils', 'syncs', 'models', 'views', 'collections']
    }
    // ... and so much more ...
]
</code></pre>

<p>})
```</p>

<p>The above build profile is designed for balancing scalability and performance.</p>

<p><strong>Examples of the grouped sets of code dependencies</strong></p>

<p>The contents of the vendor.js which is not built into a package may use some <em>no conflict</em> calls as well.</p>

<p>```javascript
// List of vendor libraries, e.g. jQuery, Underscore, Backbone, etc.<br/>
// this module is used with the r.js optimizer tool during build<br/>
// @see <a href="http://requirejs.org/docs/faq-optimization.html">http://requirejs.org/docs/faq-optimization.html</a>
define([ "jquery", "underscore", "backbone", "modernizr", "mustache" ],
function ($,        _,            Backbone,   Modernizr,   Mustache) {</p>

<pre><code>// call no conflicts so if needed you can use multiple versions of $
$.noConflict();
_.noConflict();
Backbone.noConflict();
</code></pre>

<p>});
```</p>

<p>For your application common library code.</p>

<p>```javascript
// List of utility libraries,
define([ "utils/ajax", "utils/baselib", "utils/localstorage", "utils/debug", "utils/shims" ],
function (ajax,         baselib,         localstorage,         debug) {</p>

<pre><code>return {
    "ajax" : ajax,
    "baselib" : baselib,
    "localstorage" : localstorage,
    "debug" : debug
};
// the shim only extend JavaScript when needed, e.g. Object.create
</code></pre>

<p>});
```</p>

<p>An example where you intend to use require the common models in another package file.</p>

<p>```javascript
// List of models<br/>
// models in this directory are intended for site-wide usage<br/>
// grouping site-wide models in this module (object)
// optimizes the performance and keeps dependencies organized
// when the (build) optimizer is run.
define([ "models/branding", "models/section" ],
function (Branding,          Section) {</p>

<pre><code>return {
    "Branding" : Branding,
    "Section"  : Section
};
</code></pre>

<p>});
```</p>

<h3>A quick note on code standards</h3>

<p>Notice that in the above examples the parameters may begin with lower or upper case characters. The variable names uses in the parameters that begin with <em>Uppercase</em> are <em>Constructors</em> and the <em>lowercase</em> variable names are not, they may be instances created by a constructor, or perhaps an object or function that is not meant to used with <em>new</em>.</p>

<p>The convention recommended is to use Upper CamelCase for constructors and lower camelCase for others.</p>

<h3>Common pitfall when organizing code in modules</h3>

<p>Be careful not define circular dependencies. For example, in a common <em>models</em> package (models.js) dependencies are listed for the files in your models directory</p>

<pre><code>define([ "models/branding", "models/section" ], function (branding, section)  
// ...  
return { "branding" : branding, "section", section }  
</code></pre>

<p>Then when another packages requires a common model you can access the models objects returned from your common models.js file like so...</p>

<pre><code>define([ "models", "utils" ], function (models, utils) {  
var branding = models.branding, debug = utils.debug;  
</code></pre>

<p>Perhaps after using the model a few times you get into the habit of requiring "model". Later you need add another common model with extends a model you already defined. So the pitfall begins, you add a new model inside your models directory and add a reference this same model in the model.js:</p>

<pre><code>define([ "models/branding", "models/section", "models/section-b" ], function (branding, section)  
// ...  
return { "branding" : branding, "section", section, "section-b" : section-b }
</code></pre>

<p>However in your <em>models/section-b.js</em> file you define a dependency using the model.js which returns the models in an object like so...</p>

<pre><code>define([ "models" ], function (models, utils) {  
var section = models.section;
</code></pre>

<p>Above is the mistake in models.js a dependency was added for models/section-b and in section-b a dependency is defined for model. The new models/section-b.js requires <em>model</em> and model.js requires <em>models/section-b.js</em> - a circular dependency. This should result in a load timeout error from require.js, but not tell you about the circular dependency.</p>

<p>For other common mistakes see the <a href="http://requirejs.org/docs/errors.html" title="RequireJS common errors page">COMMON ERRORS</a> page on the RequireJS site.</p>

<h4>Executing the Build with r.js</h4>

<p>If you intalled r.js with Node's npm (package manager) like so...</p>

<pre><code>&gt; npm install requirejs
</code></pre>

<p>...you can execute the build on the command line:</p>

<pre><code>&gt; r.js -o app.build.js
</code></pre>
]]></content>
  </entry>
  
</feed>
